/* ********************************
题目来源 https://www.nowcoder.com/ta/2017test?page=1

题目描述
	n 只奶牛坐在一排，每个奶牛拥有 ai 个苹果，现在你要在它们之间转移苹果，使得最
	后所有奶牛拥有的苹果数都相同，每一次，你只能从一只奶牛身上拿走恰好两个苹果到
	另一个奶牛上，问最少需要移动多少次可以平分苹果，如果方案不存在输出 -1。

输入描述:
	每个输入包含一个测试用例。每个测试用例的第一行包含一个整数 n（1 <= n <= 100）
	，接下来的一行包含 n 个整数 ai（1 <= ai <= 100）。

输出描述:
	输出一行表示最少需要移动多少次可以平分苹果，如果方案不存在则输出 -1。

示例1
输入
4
7 15 9 5
输出
3

* ********************************/

/* ********************************
简单题目 
想通了就挺简单的，，如果苹果总数不能整除人数，证明无论怎么分，总会有人多出一些
苹果。 如果能整除，那么每个人的最终的苹果数目一定是平均数，不然不可能相等。所以
只需要把低于平均数那一部分补上，把高于平均数那一部分减掉就可以了。当然如果， 补
上的那一部分不能整除2，证明这个人是不能通过2个苹果的转移来达到平均数，即无论怎么
分，也不可能每个人的苹果都一样。  如数据：
3
2 3 1
6
1 4 1
* ********************************/

#include <iostream>
#include <stdio.h>
using namespace std;

int n,a[105];
int main() {
	int cnt,flag,sum=0;
	int averApple = 0;
	cin>>n;
	for(int i=0; i<n; i++) {
		cin>>a[i];
		sum+=a[i];
	}
	if( 0 != (sum % n)) {
		cout<<-1<<endl;
		return 0;
	}
	averApple = sum/n;
	cnt = 0;

	for(int i = 0; i<n ; i++) {
		//不能用2去补齐，使该数等于平均数，即分到最后每一个人的苹果不可能相等
		if(1== (( averApple - a[i])&0x01)) {
			cout<<-1<<endl;
			return 0;
		}
		if(averApple>=a[i]) {

			cnt = cnt + ( averApple - a[i])/2;
		}

	}

	cout<<cnt<<endl;

	return 0;
}

